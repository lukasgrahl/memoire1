options
{
    output logfile = FALSE;
    output LaTeX = FALSE;
};

tryreduce
{
   U[], TC[] ;
};

block STEADY_STATE
{
    definitions
    {
    };

    identities
    {
        A[ss] = 1 ;
        P[ss] = 1 ;
        r[ss] = P[ss] * (1 / beta - (1 - delta)) ;
        mc[ss] = ((psi -1) / psi) * (1 - beta * Theta) * P[ss] ;
        w[ss] = (1 - alpha) * mc[ss] ^ (1 / (1 - alpha)) * (alpha / r[ss]) ^ (alpha / (1 - alpha)) ;
        Y[ss] = (r[ss] / (r[ss] - mc[ss] * delta * alpha)) ^ (sigma_C / (sigma_C + sigma_L)) * ((w[ss] / P[ss]) * (w[ss] / ((1 - alpha) * mc[ss])) ^ sigma_L ) ^ (1 / (sigma_C + sigma_L)) ;
        I[ss] = ((delta * alpha * mc[ss]) / r[ss]) * Y[ss] ;
        C[ss] = (1 / (Y[ss] ^ (sigma_L / sigma_C))) * ((w[ss] / P[ss]) * (w[ss] / ((1 - alpha) * mc[ss])) ^ sigma_L ) ^ (1 / sigma_C) ;
        L[ss] = (1 - alpha) * mc[ss] * Y[ss] / w[ss] ;
        K[ss] = alpha * mc[ss] * Y[ss] / r[ss] ;
    };    

};

block HOUSEHOLD
{
    definitions
    {
        u[] = C[] ^ (1 - sigma_C) / (1 - sigma_C) - L[] ^ (1 + sigma_L) / (1 + sigma_L);
    };

    controls
    {
        C[], L[], I[], K[];
    };

    objective
    {
        U[] = u[] + beta * E[][U[1]];
    };

    constraints
    {
        P[] * (C[] + I[]) = r[] * K[-1] + w[] * L[] : lambda[];
        K[] = (1 - delta) * K[-1] + I[] : q[];
    };

    identities
    {
        Q[] = q[] / lambda[] ; # Tobin's q
    };

    calibration
    {
        beta = 0.99;
        delta = 0.02;
        sigma_C = 1.5;
        sigma_L = 2.0;
    };
};

block FIRM
{
    controls
    {
        K[-1], L[];
    };

    objective
    {
        TC[] = -(r[] * K[-1] + w[] * L[]);
    };

    constraints
    {
        Y[] = A[] * K[-1] ^ alpha * L[] ^ (1 - alpha) : mc[];
    };

    calibration
    {
        alpha = 0.35;
    };
};

block TECHNOLOGY_SHOCKS
{
    identities
    {
        log(A[]) = rho_A * log(A[-1]) + epsilon_A[];
    };

    shocks
    {
        epsilon_A[];
    };

    calibration
    {
        rho_A = 0.95;
    };
};

block PRICE_SETTING
# obtain P_hat, the optimal price at pricing signal
{
    identities
    {
#        g1[] = psi / (1 - psi) *  P_hat[] ^ (- 1) * g2[] ;
#        g1[] = lambda[] * Y[] + beta * Theta * E[][g1[1]] ;
#        g2[] = lambda[] * Y[] * mc[] + beta * Theta * E[][g2[1]] ;


        P_hat[] = (psi / (psi - 1)) * g1[] ;
        g1[] = mc[] + (beta * Theta) * E[][g1[1]] ;

        P[] = (Theta  * P[-1] ^ (1 - psi) + (1 - Theta) * P_hat[] ^ (1 - psi)) ^ (1 / (1 - psi)) ;

        pi[] = P[] / P[-1] ;
    };

    calibration
    {
        Theta = .95 ;         # Calvo pricing probability
        psi = 1 ;
    };   

};

block EQUILIBRIUM
{
    identities
    {
        Y[] = I[] + C[] ; 
#        Pi[] = (Y[] - TC[]) ;
    };  

};