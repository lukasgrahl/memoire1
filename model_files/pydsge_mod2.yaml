# dfi.yaml ---
#
# Description: the model from "Monetary Policy and Speculative Stock Markets"
# Author: Gregor Boehl [mail@gregorboehl.com]
# Last-Updated: 17/11/19
#
declarations:
  name: 'dfi'
  # variables ...
  variables: [pi, c, l, mc, mc_hat, w, p, r, a, y, dy]
  parameters: [sigma_C, sigma_L]

equations:
  model:
    # Phillips Curve
    # ~ pi = beta * pi(+1) - kappa * (mc - p)
    ~ pi = beta * pi(+1) - kappa * eta * y_gap

    # dynamic IS curve
    ~ y = y(+1) - 1 / sigma_C * (i - r - rho)

    # output gap
    ~ y_gap = y_gap(+1) - 1 / sigma_C * (i - pi(+1) - rn)

    # natural interest rate
    ~ rn = rho + sigma_C * psi * delta * a(+1)

    # Euler Equation
    ~ c = c(+1) - 1 / sigma_C * (i - rho - pi(+1))

    # taylor rule
    ~ i = rho + phi_pi * pi + phi_y * y_gap + v
    # v is stochastic



    # Monetary policy shock
    ~ a = rho_a * a(-1) + e_a

    # Technology Shock
    ~ v = rho_v * v(-1) + e_v

  # constraint:
    # the actual constraint in the form r = max(..., x_bar). The constrained variable MUST be at the LHS. Here it is the ZLB. This reads r = max(rn, x_bar), hence the nominal rate is either the notational rate but never smaller than x_bar.
    
  # measurement equations
  observables:
    # Output growth
    GDP : dy + y_mean
    #ygr : y

    # Observed inflation
    Infl : pi + pi_mean

    # Observed Interest Rate
    FFR : r + 1/beta

calibration:
  parameters:
    beta    : .99
    theta   : .66
    sigma_C  : 1.5
    sigma_L : 2
    # phi_pi  : 1.7
    # phi_y   : .125
    # rho     : .8
    # rho_u   : .8
    # rho_z   : .9
    rho_a  : .7
    # sig_u   : .5
    sig_a  : .3
    # sig_r   : .3
    # psi     : 0.3
    # nub     : 0.1
    y_mean  : 0.35
    pi_mean : 0.5
    # elb_level: .07

  parafunc:

    # parameters that are functions of other parameters
    # the following functions are supported by default: exp, log, sqrt, normpdf, normcdf, normppf (=norminv)
    # additionally you can define arbitary functions in a *_funcs.py file. This file must be in the same directory as the *.yaml file and have the same name
    # example: the correponding file to this model ('dfi.yaml') must be called 'dfi_funcs.py'. It here defines the (trivial) function "calc_nu"
    # the *_funcs.py file does not need to be present if you dont' need it

    kappa   : (1-theta)*(1-beta*theta)/theta
    eta : (sigma_C * (1-alpha) + sigma_L + alpha) / (1 - alpha)
    # eta     : (sigma + psi + nub)/(1-nub)
    # nu      : calc_nu(nub) # calc nu is an external function defined in dfi_funcs.py
    # x_bar   : -1/beta + elb_level # x_bar *must* be present either as a parameter or parafunc

  covariances:
    e_a: sig_a
    # e_u: sig_u
    # e_r: sig_r

estimation:
  prior:
    # Priors are structured as follows:
    # name  : [initval, lb, ub, dist_type, dist_p1, dist_p2]
    # The initial value (initial) is currently not used during estimation and can be None
    # Lower & upper bound (lb, ub) are only used during global mode search and therefor essential, but not during sampling
    # dist_type (distribution type) can be uniform, normal, gamma, beta, inv_gamma and inv_gamma_dynare (the exact copy of what dynare does to the inverse gamma distribution).
    # uniform distribution takes lower & upper as input
    # inv_gamma_dynare function takes weird stuff as input
    # all other function take mean & std as input
    theta   : [0.7813, 0.2, 0.95, beta, 0.5, 0.10]
    # sigma   : [1.2312, 0.25, 3, normal,1.50, 0.375]
    # phi_pi  : [1.7985, 1.0, 3, normal,1.5, 0.25]
    # phi_y   : [0.0893, 0.001, 0.5, normal, 0.125, 0.05]
    # rho_u   : [.7, .01, .9999, beta, 0.5, 0.20]
    # rho_r   : [.7, .01, .9999, beta, 0.5, 0.20]
    rho_a   : [.7, .01, .9999, beta, 0.5, 0.20]
    # rho     : [0.8, 0.5, 0.975, beta, 0.75, 0.10]
    # sig_u   : [0.5, 0.025, 5, inv_gamma_dynare, 0.1, 2]
    # sig_r   : [0.5, 0.01, 3, inv_gamma_dynare, 0.1, 2]
    sig_a  : [0.5, 0.01,3 , inv_gamma_dynare, 0.1, 2]
    #nub     : [0.1, 0.001, 0.9, normal, 0.25, 0.05]

